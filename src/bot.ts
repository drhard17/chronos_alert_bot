import { Telegraf, Context } from 'telegraf';
import Imap from 'imap';
import { simpleParser } from 'mailparser';
import * as cron from 'node-cron';

interface EmailConfig {
  user?: string;
  password?: string;
  host?: string;
  port?: number;
  tls: boolean;
}

interface BotConfig {
  telegramToken?: string;
  email: EmailConfig;
}

class EmailMonitorBot {
  private bot: Telegraf;
  private imap!: Imap;
  private config: BotConfig;

  constructor(config: BotConfig) {
    const token = config.telegramToken;
    if (token === undefined) {
        throw new Error('Bot token is not provided');
    }
    this.config = config;
    this.bot = new Telegraf(token);
    this.setupImap();
    this.setupBot();
  }

  private setupImap(): void {
    const { user, password, host, port } = this.config.email;
    if (
        user === undefined ||
        password === undefined ||
        host === undefined ||
        port === undefined
    ) {
        throw new Error('Email credentials are not provided')
    }
    this.imap = new Imap({
      user,
      password,
      host,
      port,
      tls: this.config.email.tls,
      tlsOptions: { rejectUnauthorized: false }
    });

    this.imap.once('ready', () => {
      console.log('IMAP connection ready');
      this.startMonitoring();
    });

    this.imap.once('error', (err: Error) => {
      console.error('IMAP error:', err);
    });

    this.imap.once('end', () => {
      console.log('IMAP connection ended');
    });
  }

  private setupBot(): void {
    // –ö–æ–º–∞–Ω–¥–∞ —Å—Ç–∞—Ç—É—Å–∞
    this.bot.command('status', (ctx: Context) => {
        // TODO something
    });

    this.bot.command('chatid', (ctx: Context) => {
      const chatId = ctx.chat?.id;
      ctx.reply(`Chat ID: ${chatId}`);
    });

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
    this.bot.catch((err: any, ctx: Context) => {
      console.error(`Error for ${ctx.updateType}:`, err);
    });
  }

  private startMonitoring(): void {
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–∂–¥—ã–µ 2 –º–∏–Ω—É—Ç—ã
    cron.schedule('*/1 * * * *', () => {
      this.checkNewEmails();
    });
  }

  private async checkNewEmails(): Promise<void> {
    try {
      await this.openInbox();
    } catch (error) {
      console.error('Error checking emails:', error);
    }
  }

  private openInbox(): Promise<void> {
    return new Promise((resolve, reject) => {
      this.imap.openBox('INBOX', false, (err: Error | null) => {
        if (err) {
          reject(err);
          return;
        }
        this.searchEmails().then(resolve).catch(reject);
      });
    });
  }

  private searchEmails(): Promise<void> {
    return new Promise((resolve, reject) => {
      // –ò—â–µ–º –Ω–µ–ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã–µ –ø–∏—Å—å–º–∞ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 10 –º–∏–Ω—É—Ç
      const since = new Date();
      since.setMinutes(since.getMinutes() - 30);

      this.imap.search(
        ['UNSEEN', ['SINCE', since.toISOString().split('T')[0]]],
        (err: Error | null, results: number[]) => {
          if (err) {
            reject(err);
            return;
          }

          if (results.length === 0) {
            resolve();
            return;
          }

          console.log(`üì® Found ${results.length} unread emails`);

          // ‚úÖ –ö–ª—é—á–µ–≤–æ–µ —Ä–µ—à–µ–Ω–∏–µ: –∏—Å–ø–æ–ª—å–∑—É–µ–º markSeen: true
          const fetch = this.imap.fetch(results, {
            bodies: '',
            markSeen: true // IMAP —Å–µ—Ä–≤–µ—Ä —Å–∞–º –ø–æ–º–µ—á–∞–µ—Ç –ø–∏—Å—å–º–∞ –∫–∞–∫ –ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã–µ
          });

          let alertCount = 0;

          fetch.on('message', (msg: any) => {
            const chunks: Buffer[] = [];

            msg.on('body', (stream: NodeJS.ReadableStream) => {
              stream.on('data', (chunk: Buffer) => {
                chunks.push(chunk);
              });

              stream.on('end', async () => {
                try {
                  const emailBuffer = Buffer.concat(chunks);
                  const mail = await simpleParser(emailBuffer);

                  if (
                    mail.subject &&
                    mail.subject.toLowerCase().includes('alert')
                  ) {
                    console.log(`üö® ALERT: "${mail.subject}"`);
                    await this.sendAlertNotification(mail);
                    alertCount++;
                  }
                } catch (error) {
                  console.error('Error parsing email:', error);
                }
              });
            });
          });

          fetch.once('error', (err: Error) => {
            reject(err);
          });

          fetch.once('end', () => {
            resolve();
          });
        }
      );
    });
  }

  private async sendAlertNotification(mail: any): Promise<void> {
    const message = this.formatAlertMessage(mail);
    const chat_id = process.env.CHRONOS_CHAT_ID
    if (chat_id === undefined) {
        throw new Error('Chat_id is not provided')
    }
      try {
        await this.bot.telegram.sendMessage(chat_id, message);
      } catch (error) {
        console.error(`Error sending message:`, error);
      }
  }

  private formatAlertMessage(mail: any): string {
    const subject = mail.subject || '–ë–µ–∑ —Ç–µ–º—ã';
    const date =
      mail.date?.toLocaleString('ru-RU') || new Date().toLocaleString('ru-RU');
    const text = mail.text ? mail.text.substring(0, 1024) : '–ù–µ—Ç —Ç–µ–∫—Å—Ç–∞';

    return (
      `üö® ${subject}\n\n` +
      `üïí ${date}\n\n` +
      `üìù ${text}`
    );
  }

  public async start(): Promise<void> {
    // –ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ IMAP
    this.imap.connect();

    // –ó–∞–ø—É—Å–∫–∞–µ–º –±–æ—Ç–∞
    await this.bot.launch();
    console.log('Telegram bot started');

    // Graceful shutdown
    process.once('SIGINT', () => this.stop());
    process.once('SIGTERM', () => this.stop());
  }

  public stop(): void {
    this.bot.stop();
    this.imap.end();
    console.log('Bot stopped');
  }
}

// –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
const config: BotConfig = {
  telegramToken: process.env.BOT_TOKEN,
  email: {
    user: process.env.EMAIL_ADDRESS,
    password: process.env.EMAIL_PASSWORD,
    host: process.env.IMAP_HOST,
    port: Number(process.env.IMAP_PORT),
    tls: true
  }
};

// –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
const bot = new EmailMonitorBot(config);
bot.start().catch(console.error);
